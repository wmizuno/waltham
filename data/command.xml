<?xml version="1.0" encoding="UTF-8"?>
<protocol name="command_channel">

  <copyright>
    Copyright © 2008-2011 Kristian Høgsberg
    Copyright © 2010-2011 Intel Corporation
    Copyright © 2012-2013 Collabora, Ltd.
    Copyright © 2016 DENSO CORPORATION

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice (including the
    next paragraph) shall be included in all copies or substantial
    portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
  </copyright>

  <interface name="wth_display" version="1">
    <description summary="core global object">
      The core global object.  This is a special singleton object.  It
      is used for internal command channel protocol features.

      This object is automatically created when a Waltham connection is
      established.
    </description>

    <request name="client_version">
      <description summary="client's wth_display version">
	The first thing a client does on a connection is that it sends
	this request with the version number of the wth_display
	interface it implements.

	The effective version of the wth_display interface shall be
	min(server_version, client_version).
	See wth_display.server_version.
      </description>
      <arg name="client_version" type="uint"/>
    </request>

    <request name="sync">
      <description summary="asynchronous roundtrip">
	The sync request asks the server to emit the 'done' event
	on the returned wthp_callback object.  Since requests are
	handled in-order and events are delivered in-order, this can
	be used as a barrier to ensure all previous requests and the
	resulting events have been handled.

	The object returned by this request will be destroyed by the
	compositor after the callback is fired and as such the client must not
	attempt to use it after that point.

	The callback_data passed in the callback is the event serial.
      </description>
      <arg name="callback" type="new_id" interface="wthp_callback"/>
    </request>

    <request name="get_registry">
      <description summary="get global registry object">
	This request creates a registry object that allows the client
	to list and bind the global objects available from the
	compositor.
      </description>
      <arg name="registry" type="new_id" interface="wthp_registry"/>
    </request>

    <event name="error">
      <description summary="fatal error event">
	The error event is sent out when a fatal (non-recoverable)
	error has occurred.  The object_id argument is the object
	where the error occurred, most often in response to a request
	to that object.  The code identifies the error and is defined
	by the object interface.  As such, each interface defines its
	own set of error codes.  The message is an brief description
	of the error, for (debugging) convenience.
      </description>
      <arg name="object_id" type="object"/>
      <arg name="code" type="uint"/>
      <arg name="message" type="string"/>
    </event>

    <enum name="error">
      <description summary="global error values">
	These errors are global and can be emitted in response to any
	server request.
      </description>
      <entry name="invalid_object" value="0"
	     summary="server couldn't find object"/>
      <entry name="invalid_method" value="1"
	     summary="method doesn't exist on the specified interface"/>
      <entry name="no_memory" value="2"
	     summary="server is out of memory"/>
    </enum>

    <event name="delete_id">
      <description summary="acknowledge object ID deletion">
	This event is used internally by the object ID management
	logic.  When a client deletes an object, the server will send
	this event to acknowledge that it has seen the delete request.
	When the client receive this event, it will know that it can
	safely reuse the object ID.
      </description>
      <arg name="id" type="uint" />
    </event>

    <event name="server_version">
      <description summary="server's wth_display version">
	The first thing a server does on a connection is that it sends
	this event with the version number of the wth_display
	interface it implements.

	The effective version of the wth_display interface shall be
	min(server_version, client_version).
	See wth_display.client_version.
      </description>
      <arg name="server_version" type="uint"/>
    </event>
  </interface>

  <interface name="wthp_registry" version="1">
    <description summary="global registry object">
      The global registry object.  The server has a number of global
      objects that are available to all clients.  These objects
      typically represent an actual object in the server (for example,
      an input device) or they are singleton objects that provide
      extension functionality.

      When a client creates a registry object, the registry object
      will emit a global event for each global currently in the
      registry.  Globals come and go as a result of device or
      monitor hotplugs, reconfiguration or other events, and the
      registry will send out global and global_remove events to
      keep the client up to date with the changes.  To mark the end
      of the initial burst of events, the client can use the
      wth_display.sync request immediately after calling
      wth_display.get_registry.

      A client can bind to a global object by using the bind
      request.  This creates a client-side handle that lets the object
      emit events to the client and lets the client invoke requests on
      the object.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy registry interface">
        No more events will be sent through this registry object.
      </description>
    </request>

    <request name="bind">
      <description summary="bind an object to the display">
	Binds a new, client-created object to the server using the
        specified name as the identifier.
      </description>
      <arg name="name" type="uint" summary="unique name for the object"/>
      <arg name="id" type="new_id"/>
    </request>

    <event name="global">
      <description summary="announce global object">
	Notify the client of global objects.

        The event notifies the client that a global object with
        the given name is now available, and it implements the
        given version of the given interface.
      </description>
      <arg name="name" type="uint"/>
      <arg name="interface" type="string"/>
      <arg name="version" type="uint"/>
    </event>

    <event name="global_remove">
      <description summary="announce removal of global object">
	Notify the client of removed global objects.

        This event notifies the client that the global identified
        by name is no longer available.  If the client bound to
        the global using the bind request, the client should now
        destroy that object.

	The object remains valid and requests to the object will be
	ignored until the client destroys it, to avoid races between
	the global going away and a client sending a request to it.
      </description>
      <arg name="name" type="uint"/>
    </event>
  </interface>

  <interface name="wthp_callback" version="1">
    <description summary="callback object">
      Clients can handle the 'done' event to get notified when
      the related request is done.
    </description>
    <event name="done">
      <description summary="done event">
       Notify the client when the related request is done.
      </description>
      <arg name="callback_data" type="uint" summary="request-specific data for the wthp_callback"/>
    </event>
  </interface>

  <interface name="wthp_compositor" version="4">
    <description summary="the compositor singleton">
      A compositor.  This object is a singleton global.  The
      compositor is in charge of combining the contents of multiple
      surfaces into one displayable output.
    </description>

    <request name="create_surface">
      <description summary="create new surface">
	Ask the compositor to create a new surface.
      </description>
      <arg name="id" type="new_id" interface="wthp_surface"/>
    </request>

    <request name="create_region">
      <description summary="create new region">
	Ask the compositor to create a new region.
      </description>
      <arg name="id" type="new_id" interface="wthp_region"/>
    </request>
  </interface>

  <interface name="wthp_blob_factory" version="1">
    <description summary="an inefficient wthp_buffer factory">
      This is the most simple and inefficient wthp_buffer factory
      possible. The pixel data is sent inline in the Waltham connection
      and in raw. There is no provision to update buffer contents after
      it has been created.

      This interface is intended to be used during development to get
      at least some pixels across the network, before better buffer
      factories are implemented.

      When bound, the server sends 'format' events for all supported
      pixel formats.

      Buffers created by this factory can be attached to any number of
      wthp_surfaces, any time, and any number of times.
    </description>

    <enum name="error">
      <description summary="fatal error codes">
	The error codes should be better defined, but since this is a
	stop-gap interface for development, we just rely on the error
	text.
      </description>
      <entry name="fail" value="0" summary="a catch-all error code"/>
    </enum>

    <enum name="format">
      <description summary="pixel formats">
       This describes the memory layout of an individual pixel.

       All renderers should support argb8888 and xrgb8888 but any other
       formats are optional and may not be supported by the particular
       renderer in use.
      </description>
      <entry name="argb8888" value="0" summary="32-bit ARGB format"/>
      <entry name="xrgb8888" value="1" summary="32-bit RGB format"/>
      <!-- The drm format codes match the #defines in drm_fourcc.h.
           The formats actually supported by the compositor will be
           reported by the format event. -->
      <entry name="c8" value="0x20203843"/>
      <entry name="rgb332" value="0x38424752"/>
      <entry name="bgr233" value="0x38524742"/>
      <entry name="xrgb4444" value="0x32315258"/>
      <entry name="xbgr4444" value="0x32314258"/>
      <entry name="rgbx4444" value="0x32315852"/>
      <entry name="bgrx4444" value="0x32315842"/>
      <entry name="argb4444" value="0x32315241"/>
      <entry name="abgr4444" value="0x32314241"/>
      <entry name="rgba4444" value="0x32314152"/>
      <entry name="bgra4444" value="0x32314142"/>
      <entry name="xrgb1555" value="0x35315258"/>
      <entry name="xbgr1555" value="0x35314258"/>
      <entry name="rgbx5551" value="0x35315852"/>
      <entry name="bgrx5551" value="0x35315842"/>
      <entry name="argb1555" value="0x35315241"/>
      <entry name="abgr1555" value="0x35314241"/>
      <entry name="rgba5551" value="0x35314152"/>
      <entry name="bgra5551" value="0x35314142"/>
      <entry name="rgb565" value="0x36314752"/>
      <entry name="bgr565" value="0x36314742"/>
      <entry name="rgb888" value="0x34324752"/>
      <entry name="bgr888" value="0x34324742"/>
      <entry name="xbgr8888" value="0x34324258"/>
      <entry name="rgbx8888" value="0x34325852"/>
      <entry name="bgrx8888" value="0x34325842"/>
      <entry name="abgr8888" value="0x34324241"/>
      <entry name="rgba8888" value="0x34324152"/>
      <entry name="bgra8888" value="0x34324142"/>
      <entry name="xrgb2101010" value="0x30335258"/>
      <entry name="xbgr2101010" value="0x30334258"/>
      <entry name="rgbx1010102" value="0x30335852"/>
      <entry name="bgrx1010102" value="0x30335842"/>
      <entry name="argb2101010" value="0x30335241"/>
      <entry name="abgr2101010" value="0x30334241"/>
      <entry name="rgba1010102" value="0x30334152"/>
      <entry name="bgra1010102" value="0x30334142"/>
      <entry name="yuyv" value="0x56595559"/>
      <entry name="yvyu" value="0x55595659"/>
      <entry name="uyvy" value="0x59565955"/>
      <entry name="vyuy" value="0x59555956"/>
      <entry name="ayuv" value="0x56555941"/>
      <entry name="nv12" value="0x3231564e"/>
      <entry name="nv21" value="0x3132564e"/>
      <entry name="nv16" value="0x3631564e"/>
      <entry name="nv61" value="0x3136564e"/>
      <entry name="yuv410" value="0x39565559"/>
      <entry name="yvu410" value="0x39555659"/>
      <entry name="yuv411" value="0x31315559"/>
      <entry name="yvu411" value="0x31315659"/>
      <entry name="yuv420" value="0x32315559"/>
      <entry name="yvu420" value="0x32315659"/>
      <entry name="yuv422" value="0x36315559"/>
      <entry name="yvu422" value="0x36315659"/>
      <entry name="yuv444" value="0x34325559"/>
      <entry name="yvu444" value="0x34325659"/>
    </enum>

    <request name="create_buffer">
      <description summary="create a new buffer">
	Creates a new wthp_buffer by sending the pixel data verbatim
	over the Waltham connection.
      </description>

      <arg name="buffer" type="new_id" interface="wthp_buffer"/>
      <arg name="data" type="data" summary="raw pixel data"/>
      <arg name="width" type="int" summary="image width in pixels"/>
      <arg name="height" type="int" summary="image height in pixels"/>
      <arg name="stride" type="int" summary="row stride in bytes"/>
      <arg name="format" type="uint" enum="format" summary="pixel format"/>
    </request>

    <event name="format">
      <description summary="pixel format description">
	Informs the client about a valid pixel format that
	can be used for buffers. Known formats include
	argb8888 and xrgb8888.
      </description>
      <arg name="format" type="uint" enum="format" summary="buffer pixel format"/>
    </event>
  </interface>

  <interface name="wthp_buffer" version="1">
    <description summary="content for a wthp_surface">
      A buffer provides the content for a wthp_surface. Buffers are
      created through separate factory interfaces. A buffer has a width
      and a height and can be attached to a wthp_surface, but the
      mechanism by which a client provides and updates the contents is
      defined by the buffer factory interface.

      A buffer factory interface also defines whether a wthp_buffer can
      be used multiple times or only once after created, and whether it
      is possible to update the content of the buffer after it has been
      created. Failure to follow the restrictions set by the factory
      will lead to a protocol error.

      When a wthp_buffer is created from a factory interface, it will
      usually start to transfer the content immediately, and results in
      a 'complete' event once the transfer is completed.
    </description>

    <enum name="error">
      <description summary="errors related to buffer usage">
	Buffer factory interface specify what kind of uses of a
	wthp_buffer created from them is valid and what is an error. The
	errors would usually happen at wthp_surface.attach or
	wthp_surface.commit time, but the error itself is more related
	to the wthp_buffer than the surface or even the factory.
      </description>
      <entry name="illegal_use" value="0"
	     summary="the buffer cannot be used here"/>
      <entry name="stale" value="1"
	     summary="the buffer cannot be used again"/>
    </enum>

    <request name="destroy" type="destructor">
      <description summary="destroy a buffer">
      </description>
    </request>

    <event name="complete">
      <description summary="buffer content transfer is complete">
	This event signifies that the compositor has received all the
	contents of this buffer, and is now able to use it.

	The serial argument is defined by the buffer factory, or zero if
	not meaningful. It is usually used with factories that can
	update buffer contents, to identify which content update has
	completed.
      </description>
      <arg name="serial" type="uint" summary="factory-specific serial"/>
    </event>
  </interface>

  <interface name="wthp_surface" version="4">
    <description summary="an onscreen surface">
      A surface is a rectangular area that is displayed on the screen.
      It has a location, size and pixel contents.

      The size of a surface (and relative positions on it) is described
      in surface local coordinates, which may differ from the buffer
      local coordinates of the pixel content, in case a buffer_transform
      or a buffer_scale is used.

      A surface without a "role" is fairly useless, a compositor does
      not know where, when or how to present it. The role is the
      purpose of a wthp_surface. Examples of roles are a cursor for a
      pointer (as set by wthp_pointer.set_cursor), a drag icon
      (wthp_data_device.start_drag), a sub-surface
      (wthp_subcompositor.get_subsurface), and a window as defined by a
      shell protocol (e.g. wthp_shell.get_shell_surface).

      A surface can have only one role at a time. Initially a
      wthp_surface does not have a role. Once a wthp_surface is given a
      role, it is set permanently for the whole lifetime of the
      wthp_surface object. Giving the current role again is allowed,
      unless explicitly forbidden by the relevant interface
      specification.

      Surface roles are given by requests in other interfaces such as
      wthp_pointer.set_cursor. The request should explicitly mention
      that this request gives a role to a wthp_surface. Often, this
      request also creates a new protocol object that represents the
      role and adds additional functionality to wthp_surface. When a
      client wants to destroy a wthp_surface, they must destroy this 'role
      object' before the wthp_surface.

      Destroying the role object does not remove the role from the
      wthp_surface, but it may stop the wthp_surface from "playing the role".
      For instance, if a wthp_subsurface object is destroyed, the wthp_surface
      it was created for will be unmapped and forget its position and
      z-order. It is allowed to create a wthp_subsurface for the same
      wthp_surface again, but it is not allowed to use the wthp_surface as
      a cursor (cursor is a different role than sub-surface, and role
      switching is not allowed).
    </description>

    <enum name="error">
      <description summary="wthp_surface error values">
        These errors can be emitted in response to wthp_surface requests.
      </description>
      <entry name="invalid_scale" value="0" summary="buffer scale value is invalid"/>
      <entry name="invalid_transform" value="1" summary="buffer transform value is invalid"/>
    </enum>

    <request name="destroy" type="destructor">
      <description summary="delete surface">
	Deletes the surface and invalidates its object ID.
      </description>
    </request>

    <request name="attach">
      <description summary="set the surface contents">
	Set a buffer as the content of this surface.

	The new size of the surface is calculated based on the buffer
	size transformed by the inverse buffer_transform and the
	inverse buffer_scale. This means that the supplied buffer
	must be an integer multiple of the buffer_scale.

	The x and y arguments specify the location of the new pending
	buffer's upper left corner, relative to the current buffer's upper
	left corner, in surface local coordinates. In other words, the
	x and y, combined with the new surface size define in which
	directions the surface's size changes.

	Surface contents are double-buffered state, see wthp_surface.commit.

	The initial surface contents are void; there is no content.
	wthp_surface.attach assigns the given wthp_buffer as the pending
	wthp_buffer. wthp_surface.commit makes the pending wthp_buffer the new
	surface contents, and the size of the surface becomes the size
	calculated from the wthp_buffer, as described above. After commit,
	there is no pending buffer until the next attach.

	Committing a pending wthp_buffer allows the compositor to read the
	pixels in the wthp_buffer. The compositor may access the pixels at
	any time after the wthp_surface.commit request. It may take some
	time for the contents to arrive at the compositor if they have
	not been transferred already. The compositor will continue using
	old surface content and state until the new content has arrived.
	See also wthp_buffer.complete.

	If it is possible to re-use a wthp_buffer or update its
	contents, the respective buffer factory shall define how that
	works.

	Destroying the wthp_buffer after wthp_buffer.complete does not change
	the surface contents. However, if the client destroys the
	wthp_buffer before receiving the wthp_buffer.complete event, the surface
	contents become undefined immediately.

	If wthp_surface.attach is sent with a NULL wthp_buffer, the
	following wthp_surface.commit will remove the surface content.
      </description>

      <arg name="buffer" type="object" interface="wthp_buffer" allow-null="true"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <request name="damage">
      <description summary="mark part of the surface damaged">
	This request is used to describe the regions where the pending
	buffer is different from the current surface contents, and where
	the surface therefore needs to be repainted. The compositor
	ignores the parts of the damage that fall outside of the surface.

	Damage is double-buffered state, see wthp_surface.commit.

	The damage rectangle is specified in surface local coordinates.

	The initial value for pending damage is empty: no damage.
	wthp_surface.damage adds pending damage: the new pending damage
	is the union of old pending damage and the given rectangle.

	wthp_surface.commit assigns pending damage as the current damage,
	and clears pending damage. The server will clear the current
	damage as it repaints the surface.

	Alternatively, damage can be posted with wthp_surface.damage_buffer
	which uses buffer co-ordinates instead of surface co-ordinates,
	and is probably the preferred and intuitive way of doing this.

	The factory behind the the wthp_buffer might imply full surface
	damage, overriding this request. This is common when the factory
	uses a video encoder, where regions outside the original changes
	may improve in quality.
      </description>

      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <request name="frame">
      <description summary="request a frame throttling hint">
	Request a notification when it is a good time start drawing a new
	frame, by creating a frame callback. This is useful for throttling
	redrawing operations, and driving animations.

	When a client is animating on a wthp_surface, it can use the 'frame'
	request to get notified when it is a good time to draw and commit the
	next frame of animation. If the client commits an update earlier than
	that, it is likely that some updates will not make it to the display,
	and the client is wasting resources by drawing too often.

	The frame request will take effect on the next wthp_surface.commit.
	The notification will only be posted for one frame unless
	requested again. For a wthp_surface, the notifications are posted in
	the order the frame requests were committed.

	The server must send the notifications so that a client
	will not send excessive updates, while still allowing
	the highest possible update rate for clients that wait for the reply
	before drawing again. The server should give some time for the client
	to draw and commit after sending the frame callback events to let them
	hit the next output refresh.

	A server should avoid signalling the frame callbacks if the
	surface is not visible in any way, e.g. the surface is off-screen,
	or completely obscured by other opaque surfaces.

	The object returned by this request will be destroyed by the
	compositor after the callback is fired and as such the client must not
	attempt to use it after that point.

	The callback_data passed in the callback is the current time, in
	milliseconds, with an undefined base.
      </description>

      <arg name="callback" type="new_id" interface="wthp_callback"/>
    </request>

    <request name="set_opaque_region">
      <description summary="set opaque region">
	This request sets the region of the surface that contains
	opaque content.

	The opaque region is an optimization hint for the compositor
	that lets it optimize out redrawing of content behind opaque
	regions.  Setting an opaque region is not required for correct
	behaviour, but marking transparent content as opaque will result
	in repaint artifacts.

	The opaque region is specified in surface local coordinates.

	The compositor ignores the parts of the opaque region that fall
	outside of the surface.

	Opaque region is double-buffered state, see wthp_surface.commit.

	wthp_surface.set_opaque_region changes the pending opaque region.
	wthp_surface.commit copies the pending region to the current region.
	Otherwise, the pending and current regions are never changed.

	The initial value for opaque region is empty. Setting the pending
	opaque region has copy semantics, and the wthp_region object can be
	destroyed immediately. A NULL wthp_region causes the pending opaque
	region to be set to empty.
      </description>

      <arg name="region" type="object" interface="wthp_region" allow-null="true"/>
    </request>

    <request name="set_input_region">
      <description summary="set input region">
	This request sets the region of the surface that can receive
	pointer and touch events.

	Input events happening outside of this region will try the next
	surface in the server surface stack. The compositor ignores the
	parts of the input region that fall outside of the surface.

	The input region is specified in surface local coordinates.

	Input region is double-buffered state, see wthp_surface.commit.

	wthp_surface.set_input_region changes the pending input region.
	wthp_surface.commit copies the pending region to the current region.
	Otherwise the pending and current regions are never changed,
	except cursor and icon surfaces are special cases, see
	wthp_pointer.set_cursor and wthp_data_device.start_drag.

	The initial value for input region is infinite. That means the
	whole surface will accept input. Setting the pending input region
	has copy semantics, and the wthp_region object can be destroyed
	immediately. A NULL wthp_region causes the input region to be set
	to infinite.
      </description>

      <arg name="region" type="object" interface="wthp_region" allow-null="true"/>
    </request>

    <request name="commit">
      <description summary="commit pending surface state">
	Surface state (input, opaque, and damage regions, attached buffers,
	etc.) is double-buffered. Protocol requests modify the pending
	state, as opposed to current state in use by the compositor. Commit
	request atomically applies all pending state, replacing the current
	state. After commit, the new pending state is as documented for each
	related request.

	On commit, a pending wthp_buffer is applied first, all other state
	second. This means that all coordinates in double-buffered state are
	relative to the new wthp_buffer coming into use, except for
	wthp_surface.attach itself. If there is no pending wthp_buffer, the
	coordinates are relative to the current surface contents.

	All requests that need a commit to become effective are documented
	to affect double-buffered state.

	Other interfaces may add further double-buffered surface state.
      </description>
    </request>

    <event name="enter">
      <description summary="surface enters an output">
	This is emitted whenever a surface's creation, movement, or resizing
	results in some part of it being within the scanout region of an
	output.

	Note that a surface may be overlapping with zero or more outputs.
      </description>
      <arg name="output" type="object" interface="wthp_output"/>
    </event>

    <event name="leave">
      <description summary="surface leaves an output">
	This is emitted whenever a surface's creation, movement, or resizing
	results in it no longer having any part of it within the scanout region
	of an output.
      </description>
      <arg name="output" type="object" interface="wthp_output"/>
    </event>

    <!-- Version 2 additions -->

    <request name="set_buffer_transform" since="2">
      <description summary="sets the buffer transformation">
	This request sets an optional transformation on how the compositor
	interprets the contents of the buffer attached to the surface. The
	accepted values for the transform parameter are the values for
	wthp_output.transform.

	Buffer transform is double-buffered state, see wthp_surface.commit.

	A newly created surface has its buffer transformation set to normal.

	wthp_surface.set_buffer_transform changes the pending buffer
	transformation. wthp_surface.commit copies the pending buffer
	transformation to the current one. Otherwise, the pending and current
	values are never changed.

	The purpose of this request is to allow clients to render content
	according to the output transform, thus permiting the compositor to
	use certain optimizations even if the display is rotated. Using
	hardware overlays and scanning out a client buffer for fullscreen
	surfaces are examples of such optimizations. Those optimizations are
	highly dependent on the compositor implementation, so the use of this
	request should be considered on a case-by-case basis.

	Note that if the transform value includes 90 or 270 degree rotation,
	the width of the buffer will become the surface height and the height
	of the buffer will become the surface width.

	If transform is not one of the values from the
	wthp_output.transform enum the invalid_transform protocol error
	is raised.
      </description>
      <arg name="transform" type="int"/>
    </request>

    <!-- Version 3 additions -->

    <request name="set_buffer_scale" since="3">
      <description summary="sets the buffer scaling factor">
	This request sets an optional scaling factor on how the compositor
	interprets the contents of the buffer attached to the window.

	Buffer scale is double-buffered state, see wthp_surface.commit.

	A newly created surface has its buffer scale set to 1.

	wthp_surface.set_buffer_scale changes the pending buffer scale.
	wthp_surface.commit copies the pending buffer scale to the current one.
	Otherwise, the pending and current values are never changed.

	The purpose of this request is to allow clients to supply higher
	resolution buffer data for use on high resolution outputs. Its
	intended that you pick the same	buffer scale as the scale of the
	output that the surface is displayed on.This means the compositor
	can avoid scaling when rendering the surface on that output.

	Note that if the scale is larger than 1, then you have to attach
	a buffer that is larger (by a factor of scale in each dimension)
	than the desired surface size.

	If scale is not positive the invalid_scale protocol error is
	raised.
      </description>
      <arg name="scale" type="int"/>
    </request>

    <!-- Version 4 additions -->
    <request name="damage_buffer" since="4">
      <description summary="mark part of the surface damaged using buffer co-ordinates">
	This request is used to describe the regions where the pending
	buffer is different from the current surface contents, and where
	the surface therefore needs to be repainted. The compositor
	ignores the parts of the damage that fall outside of the surface.

	Damage is double-buffered state, see wthp_surface.commit.

	The damage rectangle is specified in buffer coordinates.

	The initial value for pending damage is empty: no damage.
	wthp_surface.damage_buffer adds pending damage: the new pending
	damage is the union of old pending damage and the given rectangle.

	wthp_surface.commit assigns pending damage as the current damage,
	and clears pending damage. The server will clear the current
	damage as it repaints the surface.

	This request differs from wthp_surface.damage in only one way - it
	takes damage in buffer co-ordinates instead of surface local
	co-ordinates. While this generally is more intuitive than surface
	co-ordinates, it is especially desirable when using wp_viewport
	or when a drawing library (like EGL) is unaware of buffer scale
	and buffer transform.

	Note: Because buffer transformation changes and damage requests may
	be interleaved in the protocol stream, It is impossible to determine
	the actual mapping between surface and buffer damage until
	wthp_surface.commit time. Therefore, compositors wishing to take both
	kinds of damage into account will have to accumulate damage from the
	two requests separately and only transform from one to the other
	after receiving the wthp_surface.commit.
      </description>

      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>
   </interface>

  <interface name="wthp_seat" version="5">
    <description summary="group of input devices">
      A seat is a group of keyboards, pointer and touch devices. This
      object is published as a global during start up, or when such a
      device is hot plugged.  A seat typically has a pointer and
      maintains a keyboard focus and a pointer focus.
    </description>

    <enum name="capability" bitfield="true">
      <description summary="seat capability bitmask">
        This is a bitmask of capabilities this seat has; if a member is
        set, then it is present on the seat.
      </description>
      <entry name="pointer" value="1" summary="The seat has pointer devices"/>
      <entry name="keyboard" value="2" summary="The seat has one or more keyboards"/>
      <entry name="touch" value="4" summary="The seat has touch devices"/>
    </enum>

    <event name="capabilities">
      <description summary="seat capabilities changed">
	This is emitted whenever a seat gains or loses the pointer,
	keyboard or touch capabilities.  The argument is a capability
	enum containing the complete set of capabilities this seat has.

	When the pointer capability is added, a client may create a
	wthp_pointer object using the wthp_seat.get_pointer request. This object
	will receive pointer events until the capability is removed in the
	future.

	When the pointer capability is removed, a client should destroy the
	wthp_pointer objects associated with the seat where the capability was
	removed, using the wthp_pointer.release request. No further pointer
	events will be received on these objects.

	In some compositors, if a seat regains the pointer capability and a
	client has a previously obtained wthp_pointer object of version 4 or
	less, that object may start sending pointer events again. This
	behavior is considered a misinterpretation of the intended behavior
	and must not be relied upon by the client. wthp_pointer objects of
	version 5 or later must not send events if created before the most
	recent event notifying the client of an added pointer capability.

	The above behavior also applies to wthp_keyboard and wthp_touch with the
	keyboard and touch capabilities, respectively.
      </description>
      <arg name="capabilities" type="uint" enum="capability"/>
    </event>

    <request name="get_pointer">
      <description summary="return pointer object">
	The ID provided will be initialized to the wthp_pointer interface
	for this seat.

	This request only takes effect if the seat has the pointer
	capability, or has had the pointer capability in the past.
	It is a protocol violation to issue this request on a seat that has
	never had the pointer capability.
      </description>
      <arg name="id" type="new_id" interface="wthp_pointer"/>
    </request>

    <request name="get_keyboard">
      <description summary="return keyboard object">
	The ID provided will be initialized to the wthp_keyboard interface
	for this seat.

	This request only takes effect if the seat has the keyboard
	capability, or has had the keyboard capability in the past.
	It is a protocol violation to issue this request on a seat that has
	never had the keyboard capability.
      </description>
      <arg name="id" type="new_id" interface="wthp_keyboard"/>
    </request>

    <request name="get_touch">
      <description summary="return touch object">
	The ID provided will be initialized to the wthp_touch interface
	for this seat.

	This request only takes effect if the seat has the touch
	capability, or has had the touch capability in the past.
	It is a protocol violation to issue this request on a seat that has
	never had the touch capability.
      </description>
      <arg name="id" type="new_id" interface="wthp_touch"/>
    </request>

    <!-- Version 2 additions -->

    <event name="name" since="2">
      <description summary="unique identifier for this seat">
	In a multiseat configuration this can be used by the client to help
	identify which physical devices the seat represents. Based on
	the seat configuration used by the compositor.
      </description>
      <arg name="name" type="string"/>
    </event>

    <!-- Version 5 additions -->

    <request name="release" type="destructor" since="5">
      <description summary="release the seat object">
      Using this request client can tell the server that it is not going to
	use the seat object anymore.
      </description>
    </request>

  </interface>

  <interface name="wthp_pointer" version="5">
    <description summary="pointer input device">
      The wthp_pointer interface represents one or more input devices,
      such as mice, which control the pointer location and pointer_focus
      of a seat.

      The wthp_pointer interface generates motion, enter and leave
      events for the surfaces that the pointer is located over,
      and button and axis events for button presses, button releases
      and scrolling.
    </description>

    <enum name="error">
      <entry name="role" value="0" summary="given wthp_surface has another role"/>
    </enum>

    <request name="set_cursor">
      <description summary="set the pointer surface">
	Set the pointer surface, i.e., the surface that contains the
	pointer image (cursor). This request gives the surface the role
	of a cursor. If the surface already has another role, it raises
	a protocol error.

	The cursor actually changes only if the pointer
	focus for this device is one of the requesting client's surfaces
	or the surface parameter is the current pointer surface. If
	there was a previous surface set with this request it is
	replaced. If surface is NULL, the pointer image is hidden.

	The parameters hotspot_x and hotspot_y define the position of
	the pointer surface relative to the pointer location. Its
	top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
	where (x, y) are the coordinates of the pointer location, in surface
	local coordinates.

	On surface.attach requests to the pointer surface, hotspot_x
	and hotspot_y are decremented by the x and y parameters
	passed to the request. Attach must be confirmed by
	wthp_surface.commit as usual.

	The hotspot can also be updated by passing the currently set
	pointer surface to this request with new values for hotspot_x
	and hotspot_y.

	The current and pending input regions of the wthp_surface are
	cleared, and wthp_surface.set_input_region is ignored until the
	wthp_surface is no longer used as the cursor. When the use as a
	cursor ends, the current and pending input regions become
	undefined, and the wthp_surface is unmapped.
      </description>

      <arg name="serial" type="uint" summary="serial of the enter event"/>
      <arg name="surface" type="object" interface="wthp_surface" allow-null="true"/>
      <arg name="hotspot_x" type="int" summary="x coordinate in surface-relative coordinates"/>
      <arg name="hotspot_y" type="int" summary="y coordinate in surface-relative coordinates"/>
    </request>

    <event name="enter">
      <description summary="enter event">
	Notification that this seat's pointer is focused on a certain
	surface.

	When an seat's focus enters a surface, the pointer image
	is undefined and a client should respond to this event by setting
	an appropriate pointer image with the set_cursor request.
      </description>

      <arg name="serial" type="uint"/>
      <arg name="surface" type="object" interface="wthp_surface"/>
      <arg name="surface_x" type="fixed" summary="x coordinate in surface-relative coordinates"/>
      <arg name="surface_y" type="fixed" summary="y coordinate in surface-relative coordinates"/>
    </event>

    <event name="leave">
      <description summary="leave event">
	Notification that this seat's pointer is no longer focused on
	a certain surface.

	The leave notification is sent before the enter notification
	for the new focus.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="surface" type="object" interface="wthp_surface"/>
    </event>

    <event name="motion">
      <description summary="pointer motion event">
	Notification of pointer location change. The arguments
	surface_x and surface_y are the location relative to the
	focused surface.
      </description>

      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="surface_x" type="fixed" summary="x coordinate in surface-relative coordinates"/>
      <arg name="surface_y" type="fixed" summary="y coordinate in surface-relative coordinates"/>
    </event>

    <enum name="button_state">
      <description summary="physical button state">
        Describes the physical state of a button which provoked the button
	event.
      </description>
      <entry name="released" value="0" summary="The button is not pressed"/>
      <entry name="pressed" value="1" summary="The button is pressed"/>
    </enum>

    <event name="button">
      <description summary="pointer button event">
	Mouse button click and release notifications.

	The location of the click is given by the last motion or
	enter event.
        The time argument is a timestamp with millisecond
        granularity, with an undefined base.
      </description>

      <arg name="serial" type="uint"/>
      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="button" type="uint"/>
      <arg name="state" type="uint" enum="button_state"/>
    </event>

    <enum name="axis">
      <description summary="axis types">
	Describes the axis types of scroll events.
      </description>
      <entry name="vertical_scroll" value="0"/>
      <entry name="horizontal_scroll" value="1"/>
    </enum>

    <event name="axis">
      <description summary="axis event">
	Scroll and other axis notifications.

	For scroll events (vertical and horizontal scroll axes), the
	value parameter is the length of a vector along the specified
	axis in a coordinate space identical to those of motion events,
	representing a relative movement along the specified axis.

	For devices that support movements non-parallel to axes multiple
	axis events will be emitted.

	When applicable, for example for touch pads, the server can
	choose to emit scroll events where the motion vector is
	equivalent to a motion event vector.

	When applicable, clients can transform its view relative to the
	scroll distance.
      </description>

      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="axis" type="uint" enum="axis"/>
      <arg name="value" type="fixed"/>
    </event>

    <!-- Version 3 additions -->

    <request name="release" type="destructor" since="3">
      <description summary="release the pointer object">
	Using this request client can tell the server that it is not going to
	use the pointer object anymore.

	This request destroys the pointer proxy object, so user must not call
	wthp_pointer_destroy() after using this request.
      </description>
    </request>

    <!-- Version 5 additions -->

    <event name="frame" since="5">
      <description summary="end of a pointer event sequence">
	Indicates the end of a set of events that logically belong together.
	A client is expected to accumulate the data in all events within the
	frame before proceeding.

	All wthp_pointer events before a wthp_pointer.frame event belong
	logically together. For example, in a diagonal scroll motion the
	compositor will send an optional wthp_pointer.axis_source event, two
	wthp_pointer.axis events (horizontal and vertical) and finally a
	wthp_pointer.frame event. The client may use this information to
	calculate a diagonal vector for scrolling.

	When multiple wthp_pointer.axis events occur within the same frame,
	the motion vector is the combined motion of all events.
	When a wthp_pointer.axis and a wthp_pointer.axis_stop event occur within
	the same frame, this indicates that axis movement in one axis has
	stopped but continues in the other axis.
	When multiple wthp_pointer.axis_stop events occur within in the same
	frame, this indicates that these axes stopped in the same instance.

	A wthp_pointer.frame event is sent for every logical event group,
	even if the group only contains a single wthp_pointer event.
	Specifically, a client may get a sequence: motion, frame, button,
	frame, axis, frame, axis_stop, frame.

	The wthp_pointer.enter and wthp_pointer.leave events are logical events
	generated by the compositor and not the hardware. These events are
	also grouped by a wthp_pointer.frame. When a pointer moves from one
	surface to the another, a compositor should group the
	wthp_pointer.leave event within the same wthp_pointer.frame.
	However, a client must not rely on wthp_pointer.leave and
	wthp_pointer.enter being in the same wthp_pointer.frame.
	Compositor-specific policies may require the wthp_pointer.leave and
	wthp_pointer.enter event being split across multiple wthp_pointer.frame
	groups.
      </description>
    </event>

    <enum name="axis_source">
      <description summary="axis source types">
	Describes the source types for axis events. This indicates to the
	client how an axis event was physically generated; a client may
	adjust the user interface accordingly. For example, scroll events
	from a "finger" source may be in a smooth coordinate space with
	kinetic scrolling whereas a "wheel" source may be in discrete steps
	of a number of lines.

	The "continuous" axis source is a device generating events in a
	continuous coordinate space, but using something other than a
	finger. One example for this source is button-based scrolling where
	the vertical motion of a device is converted to scroll events while
	a button is held down.
      </description>
      <entry name="wheel" value="0" summary="A physical wheel" />
      <entry name="finger" value="1" summary="Finger on a touch surface" />
      <entry name="continuous" value="2" summary="Continuous coordinate space"/>
    </enum>

    <event name="axis_source" since="5">
      <description summary="axis source event">
	Source information for scroll and other axes.

	This event does not occur on its own. It is sent before a
	wthp_pointer.frame event and carries the source information for
	all events within that frame.

	The source specifies how this event was generated. If the source is
	wthp_pointer.axis_source.finger, a wthp_pointer.axis_stop event will be
	sent when the user lifts the finger off the device.

	If the source is wthp_pointer axis_source.wheel or
	wthp_pointer.axis_source.continuous, a wthp_pointer.axis_stop event may
	or may not be sent. Whether a compositor sends a axis_stop event
	for these sources is hardware-specific and implementation-dependent;
	clients must not rely on receiving an axis_stop event for these
	scroll sources and should treat scroll sequences from these scroll
	sources as unterminated by default.

	This event is optional. If the source is unknown for a particular
	axis event sequence, no event is sent.
	Only one wthp_pointer.axis_source event is permitted per frame.

	The order of wthp_pointer.axis_discrete and wthp_pointer.axis_source is
	not guaranteed.
      </description>
      <arg name="axis_source" type="uint" enum="axis_source"/>
    </event>

    <event name="axis_stop" since="5">
      <description summary="axis stop event">
	Stop notification for scroll and other axes.

	For some wthp_pointer.axis_source types, a wthp_pointer.axis_stop event
	is sent to notify a client that the axis sequence has terminated.
	This enables the client to implement kinetic scrolling.
	See the wthp_pointer.axis_source documentation for information on when
	this event may be generated.

	Any wthp_pointer.axis events with the same axis_source after this
	event should be considered as the start of a new axis motion.

	The timestamp is to be interpreted identical to the timestamp in the
	wthp_pointer.axis event. The timestamp value may be the same as a
	preceeding wthp_pointer.axis event.
      </description>
      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="axis" type="uint" enum="axis" summary="the axis stopped with this event"/>
    </event>

    <event name="axis_discrete" since="5">
      <description summary="axis click event">
	Discrete step information for scroll and other axes.

	This event carries the axis value of the wthp_pointer.axis event in
	discrete steps (e.g. mouse wheel clicks).

	This event does not occur on its own, it is coupled with a
	wthp_pointer.axis event that represents this axis value on a
	continuous scale. The protocol guarantees that each axis_discrete
	event is always followed by exactly one axis event with the same
	axis number within the same wthp_pointer.frame. Note that the protocol
	allows for other events to occur between the axis_discrete and
	its coupled axis event, including other axis_discrete or axis
	events.

	This event is optional; continuous scrolling devices
	like two-finger scrolling on touchpads do not have discrete
	steps and do not generate this event.

	The discrete value carries the directional information. e.g. a value
	of -2 is two steps towards the negative direction of this axis.

	The axis number is identical to the axis number in the associate
	axis event.

	The order of wthp_pointer.axis_discrete and wthp_pointer.axis_source is
	not guaranteed.
      </description>
      <arg name="axis" type="uint" enum="axis" />
      <arg name="discrete" type="int"/>
    </event>
  </interface>

  <interface name="wthp_keyboard" version="5">
    <description summary="keyboard input device">
      The wthp_keyboard interface represents one or more keyboards
      associated with a seat.
    </description>

    <enum name="keymap_format">
      <description summary="keyboard mapping format">
	This specifies the format of the keymap provided to the
	client with the wthp_keyboard.keymap event.
      </description>
      <entry name="no_keymap" value="0"
	     summary="no keymap; client must understand how to interpret the raw keycode"/>
      <entry name="xkb_v1" value="1"
             summary="libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode"/>
    </enum>

    <event name="keymap">
      <description summary="keyboard mapping">
	This event provides a file descriptor to the client which can be
	memory-mapped to provide a keyboard mapping description.
      </description>
      <arg name="format" type="uint" enum="keymap_format"/>
      <arg name="keymap" type="data"/>
    </event>

    <event name="enter">
      <description summary="enter event">
	Notification that this seat's keyboard focus is on a certain
	surface.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="surface" type="object" interface="wthp_surface"/>
      <arg name="keys" type="array" summary="the currently pressed keys"/>
    </event>

    <event name="leave">
      <description summary="leave event">
	Notification that this seat's keyboard focus is no longer on
	a certain surface.

	The leave notification is sent before the enter notification
	for the new focus.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="surface" type="object" interface="wthp_surface"/>
    </event>

    <enum name="key_state">
      <description summary="physical key state">
	Describes the physical state of a key which provoked the key event.
      </description>
      <entry name="released" value="0" summary="key is not pressed"/>
      <entry name="pressed" value="1" summary="key is pressed"/>
    </enum>

    <event name="key">
      <description summary="key event">
	A key was pressed or released.
        The time argument is a timestamp with millisecond
        granularity, with an undefined base.
      </description>

      <arg name="serial" type="uint"/>
      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="key" type="uint"/>
      <arg name="state" type="uint" enum="key_state"/>
    </event>

    <event name="modifiers">
      <description summary="modifier and group state">
	Notifies clients that the modifier and/or group state has
	changed, and it should update its local state.
      </description>

      <arg name="serial" type="uint"/>
      <arg name="mods_depressed" type="uint"/>
      <arg name="mods_latched" type="uint"/>
      <arg name="mods_locked" type="uint"/>
      <arg name="group" type="uint"/>
    </event>

    <!-- Version 3 additions -->

    <request name="release" type="destructor" since="3">
      <description summary="release the keyboard object"/>
    </request>

    <!-- Version 4 additions -->

    <event name="repeat_info" since="4">
      <description summary="repeat rate and delay">
        Informs the client about the keyboard's repeat rate and delay.

        This event is sent as soon as the wthp_keyboard object has been created,
        and is guaranteed to be received by the client before any key press
        event.

        Negative values for either rate or delay are illegal. A rate of zero
        will disable any repeating (regardless of the value of delay).

        This event can be sent later on as well with a new value if necessary,
        so clients should continue listening for the event past the creation
        of wthp_keyboard.
      </description>

      <arg name="rate" type="int"
           summary="the rate of repeating keys in characters per second"/>
      <arg name="delay" type="int"
           summary="delay in milliseconds since key down until repeating starts"/>
    </event>
  </interface>

  <interface name="wthp_touch" version="5">
    <description summary="touchscreen input device">
      The wthp_touch interface represents a touchscreen
      associated with a seat.

      Touch interactions can consist of one or more contacts.
      For each contact, a series of events is generated, starting
      with a down event, followed by zero or more motion events,
      and ending with an up event. Events relating to the same
      contact point can be identified by the ID of the sequence.
    </description>

    <event name="down">
      <description summary="touch down event and beginning of a touch sequence">
	A new touch point has appeared on the surface. This touch point is
	assigned a unique @id. Future events from this touchpoint reference
	this ID. The ID ceases to be valid after a touch up event and may be
	re-used in the future.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="surface" type="object" interface="wthp_surface"/>
      <arg name="id" type="int" summary="the unique ID of this touch point"/>
      <arg name="x" type="fixed" summary="x coordinate in surface-relative coordinates"/>
      <arg name="y" type="fixed" summary="y coordinate in surface-relative coordinates"/>
    </event>

    <event name="up">
      <description summary="end of a touch event sequence">
	The touch point has disappeared. No further events will be sent for
	this touchpoint and the touch point's ID is released and may be
	re-used in a future touch down event.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="id" type="int" summary="the unique ID of this touch point"/>
    </event>

    <event name="motion">
      <description summary="update of touch point coordinates">
	A touchpoint has changed coordinates.
      </description>
      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
      <arg name="id" type="int" summary="the unique ID of this touch point"/>
      <arg name="x" type="fixed" summary="x coordinate in surface-relative coordinates"/>
      <arg name="y" type="fixed" summary="y coordinate in surface-relative coordinates"/>
    </event>

    <event name="frame">
      <description summary="end of touch frame event">
	Indicates the end of a contact point list.
      </description>
    </event>

    <event name="cancel">
      <description summary="touch session cancelled">
	Sent if the compositor decides the touch stream is a global
	gesture. No further events are sent to the clients from that
	particular gesture. Touch cancellation applies to all touch points
	currently active on this client's surface. The client is
	responsible for finalizing the touch points, future touch points on
	this surface may re-use the touch point ID.
      </description>
    </event>

    <!-- Version 3 additions -->

    <request name="release" type="destructor" since="3">
      <description summary="release the touch object"/>
    </request>
  </interface>

  <interface name="wthp_output" version="2">
    <description summary="compositor output region">
      An output describes part of the compositor geometry.  The
      compositor works in the 'compositor coordinate system' and an
      output corresponds to rectangular area in that space that is
      actually visible.  This typically corresponds to a monitor that
      displays part of the compositor space.  This object is published
      as global during start up, or when a monitor is hotplugged.
    </description>

    <enum name="subpixel">
      <description summary="subpixel geometry information">
	This enumeration describes how the physical
	pixels on an output are laid out.
      </description>
      <entry name="unknown" value="0"/>
      <entry name="none" value="1"/>
      <entry name="horizontal_rgb" value="2"/>
      <entry name="horizontal_bgr" value="3"/>
      <entry name="vertical_rgb" value="4"/>
      <entry name="vertical_bgr" value="5"/>
    </enum>

    <enum name="transform">
      <description summary="transform from framebuffer to output">
	This describes the transform that a compositor will apply to a
	surface to compensate for the rotation or mirroring of an
	output device.

	The flipped values correspond to an initial flip around a
	vertical axis followed by rotation.

	The purpose is mainly to allow clients render accordingly and
	tell the compositor, so that for fullscreen surfaces, the
	compositor will still be able to scan out directly from client
	surfaces.
      </description>

      <entry name="normal" value="0"/>
      <entry name="90" value="1"/>
      <entry name="180" value="2"/>
      <entry name="270" value="3"/>
      <entry name="flipped" value="4"/>
      <entry name="flipped_90" value="5"/>
      <entry name="flipped_180" value="6"/>
      <entry name="flipped_270" value="7"/>
    </enum>

    <event name="geometry">
      <description summary="properties of the output">
	The geometry event describes geometric properties of the output.
	The event is sent when binding to the output object and whenever
	any of the properties change.
      </description>
      <arg name="x" type="int"
	   summary="x position within the global compositor space"/>
      <arg name="y" type="int"
	   summary="y position within the global compositor space"/>
      <arg name="physical_width" type="int"
	   summary="width in millimeters of the output"/>
      <arg name="physical_height" type="int"
	   summary="height in millimeters of the output"/>
      <arg name="subpixel" type="int" enum="subpixel"
	   summary="subpixel orientation of the output"/>
      <arg name="make" type="string"
	   summary="textual description of the manufacturer"/>
      <arg name="model" type="string"
	   summary="textual description of the model"/>
      <arg name="transform" type="int" enum="transform"
	   summary="transform that maps framebuffer to output"/>
    </event>

    <enum name="mode" bitfield="true">
      <description summary="mode information">
	These flags describe properties of an output mode.
	They are used in the flags bitfield of the mode event.
      </description>
      <entry name="current" value="0x1"
	     summary="indicates this is the current mode"/>
      <entry name="preferred" value="0x2"
	     summary="indicates this is the preferred mode"/>
    </enum>

    <event name="mode">
      <description summary="advertise available modes for the output">
	The mode event describes an available mode for the output.

	The event is sent when binding to the output object and there
	will always be one mode, the current mode.  The event is sent
	again if an output changes mode, for the mode that is now
	current.  In other words, the current mode is always the last
	mode that was received with the current flag set.

	The size of a mode is given in physical hardware units of
        the output device. This is not necessarily the same as
        the output size in the global compositor space. For instance,
        the output may be scaled, as described in wthp_output.scale,
        or transformed , as described in wthp_output.transform.
      </description>
      <arg name="flags" type="uint" enum="mode" summary="bitfield of mode flags"/>
      <arg name="width" type="int" summary="width of the mode in hardware units"/>
      <arg name="height" type="int" summary="height of the mode in hardware units"/>
      <arg name="refresh" type="int" summary="vertical refresh rate in mHz"/>
    </event>

    <event name="done" since="2">
      <description summary="sent all information about output">
        This event is sent after all other properties has been
        sent after binding to the output object and after any
        other property changes done after that. This allows
        changes to the output properties to be seen as
        atomic, even if they happen via multiple events.
      </description>
    </event>

    <event name="scale" since="2">
      <description summary="output scaling properties">
	This event contains scaling geometry information
        that is not in the geometry event. It may be sent after
        binding the output object or if the output scale changes
        later. If it is not sent, the client should assume a
	scale of 1.

	A scale larger than 1 means that the compositor will
	automatically scale surface buffers by this amount
	when rendering. This is used for very high resolution
	displays where applications rendering at the native
	resolution would be too small to be legible.

	It is intended that scaling aware clients track the
	current output of a surface, and if it is on a scaled
	output it should use wthp_surface.set_buffer_scale with
	the scale of the output. That way the compositor can
	avoid scaling the surface, and the client can supply
	a higher detail image.
      </description>
      <arg name="factor" type="int" summary="scaling factor of output"/>
    </event>
  </interface>

  <interface name="wthp_region" version="1">
    <description summary="region interface">
      A region object describes an area.

      Region objects are used to describe the opaque and input
      regions of a surface.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy region">
	Destroy the region.  This will invalidate the object ID.
      </description>
    </request>

    <request name="add">
      <description summary="add rectangle to region">
	Add the specified rectangle to the region.
      </description>

      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <request name="subtract">
      <description summary="subtract rectangle from region">
	Subtract the specified rectangle from the region.
      </description>

      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

  </interface>

  <interface name="wthp_farstream" version="1">
    <description summary="Farstream initialization">
      This interface is used for establishing Farstream connection
      parameters. This is a global singleton interface.

      The parties are Transmitter and Receiver. Transmitter will
      initiate the connection. Transmitter will be sending video frames
      to the Receiver. Transmitter is the Waltham client, and Receiver
      is the Waltham server.

      The client starts by creating a wthp_farstream_remote object with
      'connect' request. Then the client gets the codec list from
      Farstream and sends 'wthp_farstream_remote.codec_offer' request.
      The server feeds the codec list to Farstream and gets the common
      codec list back, sending it using
      'wthp_farstream_remote.codec_answer' event. The client waits for
      'wthp_farstream_remote.port' and
      'wthp_farstream_remote.codec_answer' events, and relays the
      information back to Farstream. Then the Farstream video stream
      pipeline is set to playing state, and frames can be delivered
      through it. For each frame submitted into the pipeline, the
      client will create a wthp_buffer with
      'wthp_farstream_remote.create_buffer'.

      The Farstream connection can be torn down at any moment by
      destroying the wthp_farstream_remote object. It may also error
      out at any time with 'wthp_farstream_remote.error' event.
    </description>

    <request name="destroy" type="destructor">
      <description summary="unbind from this global">
	There are no side-effects from unbinding.
      </description>
    </request>

    <request name="connect">
      <description summary="negotiate a new Farstream connection">
	IP-address and UDP ports are needed from both the client and the
	server. The IP-addresses are assumed to be already known by
	each other from the Waltham connection.

	This request announces client's Farstream port base to the
	server. Farstream may use more than one port, starting with the
	port base.
      </description>

      <arg name="port" type="uint" summary="UDP port base"/>
      <arg name="remote" type="new_id" interface="wthp_farstream_remote"/>
    </request>
  </interface>

  <interface name="wthp_farstream_remote" version="1">
    <description summary="buffer factory based on Farstream">
      This interface represents a Farstream connection and a one-way
      video stream. You can create wthp_buffer objects representing a
      frame sent through the stream.

      When this object is created, the server will send the 'port'
      event.

      Right after creating this object, the client needs to send the
      supported codec list to the server with 'codec_offer' request.
      The server will eventually reply with the common codec list using
      the 'codec_answer' event. This negotiation can happen at any time
      as requested by Farstream (the library).

      The client must have received the 'port' event and ensured the
      Farstream video stream is up before it starts using
      'create_buffer' request.
    </description>

    <request name="destroy" type="destructor">
      <description summary="Disconnect this Farstream connection">
	Disconnects this Farstream connection. The effect to
	wthp_buffer objects is the same as receiving the 'error' event.
      </description>
    </request>

    <request name="codec_offer">
      <description summary="list codecs supported by client">
	Carry the list of client supported codecs to the server. The
	server must reply with one 'codec_answer' event. This
	request-event exchange is a codec (re)negotiation.

	The codec list data is a string in the format Farstream's
	fs_codec_list_from_keyfile() accepts.
      </description>

      <arg name="list" type="string" summary="codec list data"/>
    </request>

    <request name="create_buffer">
      <description summary="create a reference to a frame in video stream">
	This creates wthp_buffer referring to the given frame to be
	transmitted in the Farstream video stream.

	The wthp_buffer object should be destroyed as soon as it has been
	attached and committed to a wthp_surface. This factory
	uses a stream (a video encoder/decoder) and the compositor does
	not preserve past frames. An attempt to use a past frame from a
	stream raises the protocol error wthp_buffer.error.stale.
      </description>

      <arg name="frame_id" type="uint"/>
      <arg name="id" type="new_id" interface="wthp_buffer"/>
    </request>

    <event name="port">
      <description summary="deliver server-side Farstream port base">
	This event is sent once as a reply to creating a
	wthp_farstream_remote object.

	This event announces server's Farstream UDP port base to the
	client. Farstream may use more than one port, starting with
	the port base.

	It is also possible to get 'error' event instead.
      </description>

      <arg name="port" type="uint" summary="UDP port base"/>
    </event>

    <event name="codec_answer">
      <description summary="list codecs supported by both">
	Carry the list of codecs supported by both the client and the
	server to the client. This event must be sent as a reply to a
	'codec_offer' exactly once, and never otherwise.

	The codec list data is a string in the format Farstream's
	fs_codec_list_from_keyfile() accepts.

	The list may be empty to indicate codec negotiation failure, in
	which case none of the codecs listed in the 'codec_offer' were
	suitable.
      </description>

      <arg name="list" type="string" summary="codec list data"/>
    </event>

    <event name="error">
      <description summary="error with Farstream">
	An error occurred and the Farstream connection is no longer
	usable. Client must destroy this object.

	All wthp_buffers that have already signalled "complete" are
	still usable. Those that have not signalled "complete" might
	never complete, and should be destroyed without using them.
	If non-complete wthp_buffer was attached to a wthp_surface,
	the surface contents have become undefined.
      </description>

      <arg name="code" type="uint" summary="error code"/>
      <arg name="message" type="string" summary="error message"/>
    </event>
  </interface>

  <interface name="ivi_surface" version="1">
    <description summary="application interface to surface in ivi compositor"/>

    <request name="destroy" type="destructor">
      <description summary="destroy ivi_surface">
        This removes link from ivi_id to wthp_surface and destroys ivi_surface.
        The ID, ivi_id, is free and can be used for surface_create again.
      </description>
    </request>

    <event name="configure">
      <description summary="suggest resize">
        The configure event asks the client to resize its surface.

        The size is a hint, in the sense that the client is free to
        ignore it if it doesn't resize, pick a smaller size (to
        satisfy aspect ratio or resize in steps of NxM pixels).

        The client is free to dismiss all but the last configure
        event it received.

        The width and height arguments specify the size of the window
        in surface-local coordinates.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </event>
  </interface>

  <interface name="ivi_application" version="1">
    <description summary="create ivi-style surfaces">
      This interface is exposed as a global singleton.
      This interface is implemented by servers that provide IVI-style user interfaces.
      It allows clients to associate a ivi_surface with wthp_surface.
    </description>

    <enum name="error">
      <entry name="role" value="0" summary="given wthp_surface has another role"/>
      <entry name="ivi_id" value="1" summary="given ivi_id is assigned to another wthp_surface"/>
    </enum>

    <request name="surface_create">
      <description summary="create ivi_surface with numeric ID in ivi compositor">
        This request gives the wthp_surface the role of an IVI Surface. Creating more than
        one ivi_surface for a wthp_surface is not allowed. Note, that this still allows the
        following example:

         1. create a wthp_surface
         2. create ivi_surface for the wthp_surface
         3. destroy the ivi_surface

        surface_create will create a interface:ivi_surface with numeric ID; ivi_id in
        ivi compositor. These ivi_ids are defined as unique in the system to identify
        it inside of ivi compositor. The ivi compositor implements business logic how to
        set properties of the surface with ivi_id according to status of the system.
        E.g. a unique ID for Car Navigation application is used for implementing special
        logic of the application about where it shall be located.
        The server regards following cases as protocol errors and disconnects the client.
         - wthp_surface already has an nother role.
         - ivi_id is already assigned to an another wthp_surface.

        If client destroys ivi_surface or wthp_surface which is assigne to the ivi_surface,
        ivi_id which is assigned to the ivi_surface is free for reuse.
      </description>
      <arg name="ivi_id" type="uint"/>
      <arg name="surface" type="object" interface="wthp_surface"/>
      <arg name="id" type="new_id" interface="ivi_surface"/>
    </request>

  </interface>

  <interface name="dummy" version="1">
    <request name="dummy_request">
    </request>
  </interface>

</protocol>
